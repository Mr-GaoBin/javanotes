# 疑难杂症总汇

## 依赖倒置原则

1. 在设计模式中有对依赖倒置原则。程序要尽量依赖于抽象，不依赖于具体。 从Java语法上，这种方式是使用接口引用指向具体实现。
   

2. 面向接口编程，提高程序宽展性,实现代码解耦，以后修改维护好些
   声明一个接口的变量（接口的引用）可以指向一个实现类（实现该接口的类）的实例， 但是该接口的变量不能使用实现类中有，接口中没有的方法（实现类中没有重写的方法，自添加的方法）
   详细解释：

>* ArrayList不是继承List接口，是实现了List接口。 写成ArrayList arrayList = newArrayList();这样不会有任何问题。
>  和List list = new ArrayList();相比这2个写是有区别的。
>
>* arrayList是一个ArrayList对象，它可以使用ArrayList的所有方法。
>* List是接口，它是不可以被实例化的（接口是个抽象类），所以必须以它的实现类去实例化它。
>* list对象虽然也是被实例化为ArrayList但是它实际是List对象，list只能使用ArrayList中已经实现了的List接口中的方法，ArrayList中那些自己的、没有在List接口定义的方法是不可以被访问到的。
>* 用接口去做是有它的好处的，如果你把类型定义成ArrayList(也就是一个具体的实现类)那么就只能接收这一种类型的数据了，如果要是定义为List那么不仅可以接收ArrayList的对象还可以接收LinkedList的对象，这样程序就灵活了。



|-----------------------------------------------------------------------------------------------------------------|

### java反射机制

>三个反射包中的类：
>
>- Constructor：代表类的单个构造方法，通过Constructor我们可执行一个类的某个构造方法（有参或者无参）来创建对象时。
>- Method：代表类中的单个方法，可以用于执行类的某个普通方法，有参或无参，并可以接收返回值。
>- Field：代表类中的单个属性，用于set或get属性
>- AccessibleObject：以上三个类的父类，提供了构造方法，普通方法，和属性的访问控制的能力。
>
>使用Class类中的方法可以获得该类中的所有Constructor对象，Method对象，和Field对象。但是任然无法访问私有化的构造方法，普通方法，和私有属性，此时我们可以使用他们继承父类(AccessibleObject)中的setAccessible（）方法，来设置或取消访问检查，以达到访问私有对象的目的。

优点：

- 能够运行时动态获取类的实例，大大提高了系统的灵活性和扩展性；
- 与java动态编译相结合，可以实现无比强大的功能。

缺点：

- 使用反射的性能较低；
- 使用反射来说相对不安全；
- 破坏了类的封装性，可以通过反射来获取这个类的属性，和私有方法。

|-----------------------------------------------------------------------------------------------------------------|

### private修饰的方法可以通过反射访问，那么private的意义是什么

```apl
Java的private修饰符不是为了绝对安全设计的，而是对于类的封装，用户常规使用Java的一种约束
```

|-----------------------------------------------------------------------------------------------------------------|



### 深拷贝和浅拷贝

|-----------------------------------------------------------------------------------------------------------------|

### 值传递和引用传递

|-----------------------------------------------------------------------------------------------------------------|

### 动态代理和静态代理

```apl
		代理模式：为其他对象提供一种代理以控制对这个对象的访问
		好处：降低代码的耦合度，实现了代码的解耦，提高了代码的复用性
```

|-----------------------------------------------------------------------------------------------------------------|

### 分布式事务

```apl
本地事务
在计算机系统中，更多的是通过关系型数据库来控制事务，这是利用数据库本身的事务特性来实现的，因此叫数据库事务，由于应用主要靠关系数据库来控制事务，而数据库通常和应用在同一个服务器，所以基于关系型数据库的事务又被称为本地事务。

随着互联网的快速发展，软件系统由原来的单体应用转变为分布式应用

分布式系统会把一个应用系统拆分为可独立部署的多个服务，因此需要服务与服务之间远程协作才能完成事务操作，这种分布式系统环境下由不同的服务之间通过网络远程协作完成事务称之为分布式事务，例如用户注册送积分事务、创建订单减库存事务，银行转账事务等都是分布式事务。
```

* 案例

本地事务

```apl
begin transaction；
    //1.本地数据库操作：张三减少金额
    //2.本地数据库操作：李四增加金额
commit transation;
```

 在分布式环境下

```apl
begin transaction；
    //1.本地数据库操作：张三减少金额
    //2.远程调用：让李四增加金额
commit transation;
```

 可以设想，当远程调用让李四增加金额成功了，由于网络问题远程调用并没有返回，此时本地事务提交失败就回滚了张三减少金额的操作，此时张三和李四的数据就不一致了。

 因此在分布式架构的基础上，传统数据库事务就无法使用了，张三和李四的账户不在一个数据库中甚至不在一个应用系统里，实现转账事务需要通过远程调用，由于网络问题就会导致分布式事务问题。

|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|

### 分布式锁

```
当多个进程不在同一个系统中，用分布式锁控制多个进程对资源的访问
```

分布式锁的特点

为了确保分布式锁可用，至少要确保锁的实现同时满足以下四个条件：

1、**互斥性**：任意时刻，只能有一个客户端获取锁，不能同时有两个客户端获取到锁。

2、**安全性**：锁只能被持有该锁的客户端删除，不能由其它客户端删除。

3、**死锁**：获取锁的客户端因为某些原因（如down机等）而未能释放锁，其它客户端再也无法获取到该锁。

4、**容错**：当部分节点（redis节点等）down机时，客户端仍然能够获取锁和释放锁。

|-----------------------------------------------------------------------------------------------------------------|





|-----------------------------------------------------------------------------------------------------------------|







### 内存溢出



|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|

### 内存泄漏

|-----------------------------------------------------------------------------------------------------------------

### 内部类

|-----------------------------------------------------------------------------------------------------------------|

### 自动拆装箱

```apl
在java中new一个对象是存储在堆里的，对于我们经常操作的数据类型，每次创建对象这样太消耗资源，因此java提供了8个基本数据类型，存储在栈里。用起来更方便。
让基本数据类型的变量具有类中对象的特征。
基本数据类型，使用起来非常方便，但是没有对应的方法来操作这些基本类型的数据，可以使用一个类，把基本数据类型的数据装起来，这个这样我们可以调用类中的方法。
```

|-----------------------------------------------------------------------------------------------------------------|

### string，Stringbuffer和springbuild

|-----------------------------------------------------------------------------------------------------------------|

### native, volatile关键字作用!各举一 个java中的例子

|-----------------------------------------------------------------------------------------------------------------|

